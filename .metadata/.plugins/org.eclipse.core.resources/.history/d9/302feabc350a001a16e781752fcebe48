/*
 * tubiiELLIE.h
 *
 *  Created on: Mar 20, 2015
 *      Author: Ian
 */
#include "tubiiUtil.h"

#ifndef TUBIIELLIE_H_
#define TUBIIELLIE_H_

#define GENERIC 0
#define TELLIE 1
#define SMELLIE 2
#define PGT 3
#define OTHER 4

void *MappedGTDelayBaseAddress;
void *MappedDelayBaseAddress;
void *MappedSDelayBaseAddress;
void *MappedTDelayBaseAddress;
void *MappedHappyBaseAddress;
void *MappedPulserBaseAddress;
void *MappedSPulserBaseAddress;
void *MappedTPulserBaseAddress;
void *MappedDelayLengthenBaseAddress;
void *MappedAsyncModeBaseAddress;
void *MappedEllieControlBaseAddress;
void *MappedDelayControlBaseAddress;

int Pulser(float rate, float length, u32 nPulse, u32 pulser_id, void* MappedBaseAddress)
{
  if(rate < 0 || rate > 1000000){
	Log(WARNING, "TUBii: pulser rate is outside acceptable range.");
	sprintf(tubii_err, "Tubii: pulser rate is outside acceptable range.");
	return -1;
  }

  if(length < 0 ){
	Log(WARNING, "TUBii: Pulse width is too short.");
	sprintf(tubii_err, "Tubii: Pulse width is too short.");
	return -1;
  }
  else if(rate!=0 && length/(1.0e9) > 1.0/(rate) ){
	Log(WARNING, "TUBii: Pulse width is longer than period.");
	sprintf(tubii_err, "Tubii: Pulse width is longer than period.");
	return -1;
  }

  u32 period = HunMHz/rate;
  if(rate==0) period=0;

  u32 width = period - length*ns; // Due to bad planning, width is length of time pulse is low

  if( pulser_id == 0) Log(NOTICE, "TUBii: Setting Generic Pulser to %f Hz for %d pulses.", rate, nPulse);
  else if( pulser_id == 1) Log(NOTICE, "TUBii: Setting TELLIE Pulser to %f Hz for %d pulses.", rate, nPulse);
  else if( pulser_id == 2) Log(NOTICE, "TUBii: Setting SMELLIE Pulser to %f Hz for %d pulses.", rate, nPulse);
  else if( pulser_id == 3) Log(NOTICE, "TUBii: Setting TUBii PGT to %f Hz.", rate);

  // 0 is pulse width, 1 is period, 3 is no. of pulses
  mWriteReg((u32) MappedBaseAddress, RegOffset0, width);
  mWriteReg((u32) MappedBaseAddress, RegOffset1, period);
  mWriteReg((u32) MappedBaseAddress, RegOffset3, nPulse);

  return 0;
}

double GetRate(void* MappedBaseAddress)
{
  u32 period= mReadReg((u32) MappedBaseAddress, RegOffset1);
  float rate= HunMHz/period;
  if(period==0) rate=0;

  return rate;
}

double GetWidth(void* MappedBaseAddress)
{
  float width= (mReadReg((u32) MappedBaseAddress, RegOffset1) - mReadReg((u32) MappedBaseAddress, RegOffset0));
  width *= 1/ns;

  return width;
}

int GetNPulses(void* MappedBaseAddress)
{
  return mReadReg((u32) MappedBaseAddress, RegOffset3);
}

int Delay(u32 delay, void* MappedBaseAddress)
{
  delay *= ns;

  if(delay<0){
	Log(WARNING, "TUBii: delay length is outside acceptable range.");
	sprintf(tubii_err, "Tubii: delay length is outside acceptable range.");
	return -1;
  }

  // Set Delay
  mWriteReg((u32) MappedBaseAddress, RegOffset3, delay);
  return 0;
}

int GetDelayLength(void* MappedBaseAddress)
{
  return mReadReg((u32) MappedBaseAddress, RegOffset3)/ns;
}

int Lengthen(char* dArg)
{
  u32 length=0;
  safe_strtoul(dArg,&length);
  mWriteReg((u32) MappedDelayLengthenBaseAddress, RegOffset1, length);
  mWriteReg((u32) MappedDelayLengthenBaseAddress, RegOffset2, length);

  return 0;
}

void SetAsyncDelayMode(u32 mode)
{
  mWriteReg((u32) MappedAsyncModeBaseAddress, RegOffset0, mode);
}

int GetAsyncDelayMode()
{
  return mReadReg((u32) MappedAsyncModeBaseAddress, RegOffset0);
}

void SetSmellieDelayMode(u32 mode)
{
  mWriteReg((u32) MappedDelayControlBaseAddress, RegOffset0, mode);
}

int GetSmellieDelayMode()
{
  return mReadReg((u32) MappedDelayControlBaseAddress, RegOffset0);
}

void SetTellieTriggerMode(u32 option)
{
  mWriteReg((u32) MappedEllieControlBaseAddress, RegOffset0, option);
}

int GetTellieTriggerMode()
{
  return mReadReg((u32) MappedEllieControlBaseAddress, RegOffset0);
}

#endif /* TUBIIELLIE_H_ */
